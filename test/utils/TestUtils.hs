{-# LANGUAGE CPP #-}
module TestUtils
  (
    cdAndDo
  , withFileLogging
  , setupStackFiles
  , ghc84
  , hieCommand
  , hieCommandVomit
  , hieCommandExamplePlugin
  ) where

import           Control.Exception
import           Control.Monad
import           Data.Aeson.Types (typeMismatch)
import           Data.Text (pack)
import           Data.Yaml
import qualified Language.Haskell.LSP.Core as Core
import           System.Directory
import           System.FilePath
import qualified System.Log.Logger as L


-- ---------------------------------------------------------------------

cdAndDo :: FilePath -> IO a -> IO a
cdAndDo path fn = do
  old <- getCurrentDirectory
  bracket (setCurrentDirectory path) (\_ -> setCurrentDirectory old)
          $ const fn

withFileLogging :: FilePath -> IO a -> IO a
withFileLogging logFile f = do
  let logDir = "./test-logs"
      logPath = logDir </> logFile

  dirExists <- doesDirectoryExist logDir
  unless dirExists $ createDirectory logDir

  exists <- doesFileExist logPath
  when exists $ removeFile logPath

  Core.setupLogger (Just logPath) ["hie"] L.DEBUG

  f

-- ---------------------------------------------------------------------

setupStackFiles :: IO ()
setupStackFiles =
  forM_ files $ \f -> do
    resolver <- readResolver
    writeFile (f ++ "stack.yaml") $ stackFileContents resolver
    removePathForcibly (f ++ ".stack-work")

-- ---------------------------------------------------------------------

files :: [FilePath]
files =
  [  "./test/testdata/"
   , "./test/testdata/gototest/"
   , "./test/testdata/addPackageTest/cabal/"
   , "./test/testdata/addPackageTest/hpack/"
   , "./test/testdata/redundantImportTest/"
   , "./test/testdata/completion/"
   , "./test/testdata/definition/"
   , "./bench/sample/"
  ]

ghc84 :: Bool
#if (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,0,0)))
ghc84 = True
#else
ghc84 = False
#endif

stackYaml :: FilePath
stackYaml =
#if (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,3,0)))
  "stack.yaml"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,2,0)))
  "stack-8.4.2.yaml"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,2,2,0)))
  "stack-8.2.2.yaml"
#elif __GLASGOW_HASKELL__ >= 802
  "stack-8.2.1.yaml"
#else
  "stack-8.0.2.yaml"
#endif

-- | The command to execute the version of hie for the current compiler.
-- Make sure to disable the STACK_EXE and GHC_PACKAGE_PATH environment
-- variables or else it messes up -- ghc-mod.
-- We also need to unset STACK_EXE manually inside the tests if they are
-- run with `stack test`
hieCommand :: String
hieCommand = "stack exec --no-stack-exe --no-ghc-package-path --stack-yaml=" ++ stackYaml ++
             " hie -- -d -l test-logs/functional-hie-" ++ stackYaml ++ ".log"

hieCommandVomit :: String
hieCommandVomit = hieCommand ++ " --vomit"

hieCommandExamplePlugin :: String
hieCommandExamplePlugin = hieCommand ++ " --example"

-- |Choose a resolver based on the current compiler, otherwise HaRe/ghc-mod will
-- not be able to load the files
readResolver :: IO String
readResolver = readResolverFrom stackYaml

newtype StackResolver = StackResolver String

instance FromJSON StackResolver where
  parseJSON (Object x) = StackResolver <$> x .: pack "resolver"
  parseJSON invalid = typeMismatch "StackResolver" invalid

readResolverFrom :: FilePath -> IO String
readResolverFrom yamlPath = do
  result <- decodeFileEither yamlPath
  case result of
    Left err -> error $ yamlPath ++ " parsing failed: " ++ show err
    Right (StackResolver res) -> return res

-- ---------------------------------------------------------------------

stackFileContents :: String -> String
stackFileContents resolver = unlines
  [ "# WARNING: THIS FILE IS AUTOGENERATED IN test/Main.hs. IT WILL BE OVERWRITTEN ON EVERY TEST RUN"
  , "resolver: " ++ resolver
  , "packages:"
  , "- '.'"
  , "extra-deps: []"
  , "flags: {}"
  , "extra-package-dbs: []"
  ]
-- ---------------------------------------------------------------------
